use crate::vl1::{Endpoint, Address, Identity};
use std::hash::{Hash, Hasher};

/// A signed object generated by nodes to inform the network where they may be found.
///
/// By default this will just enumerate the roots used by this node, but nodes with
/// static IPs can also list physical IP/port addresses where they can be reached with
/// no involvement from a root at all.
#[derive(Clone, PartialEq, Eq, PartialOrd, Ord)]
pub struct Locator {
    pub(crate) signer: Address,
    pub(crate) timestamp: i64,
    pub(crate) endpoints: Vec<Endpoint>,
    pub(crate) signature: Vec<u8>,
}

impl Locator {
    pub fn create(id: &Identity, ts: i64, endpoints: &[Endpoint]) -> Option<Locator> {
        let mut loc = Locator {
            signer: id.address(),
            timestamp: ts,
            endpoints: endpoints.to_vec(),
            signature: Vec::new()
        };
        loc.endpoints.sort_unstable();
        loc.endpoints.dedup();
        Some(loc)
    }
}

impl Hash for Locator {
    fn hash<H: Hasher>(&self, state: &mut H) {
        if !self.signature.is_empty() {
            state.write(self.signature.as_slice());
        } else {
            state.write_u64(self.signer.to_u64());
            state.write_i64(self.timestamp);
            for e in self.endpoints.iter() {
                e.hash(state);
            }
        }
    }
}
